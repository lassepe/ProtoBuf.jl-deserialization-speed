# Autogenerated using ProtoBuf.jl v1.0.15 on 2024-01-22T14:43:16.547
# original file: /home/lassepe/worktree/BugReports/ProtoBuf.jl-deserialization-speed/protos/map.proto (proto2 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export MapPoint, var"RoadEdge.RoadEdgeType", var"RoadLine.RoadLineType"
export var"TrafficSignalLaneState.State", var"LaneCenter.LaneType", Crosswalk, StopSign
export SpeedBump, RoadEdge, RoadLine, TrafficSignalLaneState, LaneCenter, DynamicState
export MapFeature, Map

struct MapPoint
    x::Float64
    y::Float64
    z::Float64
end
PB.default_values(::Type{MapPoint}) = (;x = zero(Float64), y = zero(Float64), z = zero(Float64))
PB.field_numbers(::Type{MapPoint}) = (;x = 1, y = 2, z = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MapPoint})
    x = zero(Float64)
    y = zero(Float64)
    z = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            x = PB.decode(d, Float64)
        elseif field_number == 2
            y = PB.decode(d, Float64)
        elseif field_number == 3
            z = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return MapPoint(x, y, z)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MapPoint)
    initpos = position(e.io)
    x.x != zero(Float64) && PB.encode(e, 1, x.x)
    x.y != zero(Float64) && PB.encode(e, 2, x.y)
    x.z != zero(Float64) && PB.encode(e, 3, x.z)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MapPoint)
    encoded_size = 0
    x.x != zero(Float64) && (encoded_size += PB._encoded_size(x.x, 1))
    x.y != zero(Float64) && (encoded_size += PB._encoded_size(x.y, 2))
    x.z != zero(Float64) && (encoded_size += PB._encoded_size(x.z, 3))
    return encoded_size
end

@enumx var"RoadEdge.RoadEdgeType" TYPE_UNKNOWN=0 TYPE_ROAD_EDGE_BOUNDARY=1 TYPE_ROAD_EDGE_MEDIAN=2

@enumx var"RoadLine.RoadLineType" TYPE_UNKNOWN=0 TYPE_BROKEN_SINGLE_WHITE=1 TYPE_SOLID_SINGLE_WHITE=2 TYPE_SOLID_DOUBLE_WHITE=3 TYPE_BROKEN_SINGLE_YELLOW=4 TYPE_BROKEN_DOUBLE_YELLOW=5 TYPE_SOLID_SINGLE_YELLOW=6 TYPE_SOLID_DOUBLE_YELLOW=7 TYPE_PASSING_DOUBLE_YELLOW=8

@enumx var"TrafficSignalLaneState.State" LANE_STATE_UNKNOWN=0 LANE_STATE_ARROW_STOP=1 LANE_STATE_ARROW_CAUTION=2 LANE_STATE_ARROW_GO=3 LANE_STATE_STOP=4 LANE_STATE_CAUTION=5 LANE_STATE_GO=6 LANE_STATE_FLASHING_STOP=7 LANE_STATE_FLASHING_CAUTION=8

@enumx var"LaneCenter.LaneType" TYPE_UNDEFINED=0 TYPE_FREEWAY=1 TYPE_SURFACE_STREET=2 TYPE_BIKE_LANE=3

struct Crosswalk
    polygon::Vector{MapPoint}
end
PB.default_values(::Type{Crosswalk}) = (;polygon = Vector{MapPoint}())
PB.field_numbers(::Type{Crosswalk}) = (;polygon = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Crosswalk})
    polygon = PB.BufferedVector{MapPoint}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, polygon)
        else
            PB.skip(d, wire_type)
        end
    end
    return Crosswalk(polygon[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Crosswalk)
    initpos = position(e.io)
    !isempty(x.polygon) && PB.encode(e, 1, x.polygon)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Crosswalk)
    encoded_size = 0
    !isempty(x.polygon) && (encoded_size += PB._encoded_size(x.polygon, 1))
    return encoded_size
end

struct StopSign
    lane::Vector{Int64}
    position::Union{Nothing,MapPoint}
end
PB.default_values(::Type{StopSign}) = (;lane = Vector{Int64}(), position = nothing)
PB.field_numbers(::Type{StopSign}) = (;lane = 1, position = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:StopSign})
    lane = PB.BufferedVector{Int64}()
    position = Ref{Union{Nothing,MapPoint}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, lane)
        elseif field_number == 2
            PB.decode!(d, position)
        else
            PB.skip(d, wire_type)
        end
    end
    return StopSign(lane[], position[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::StopSign)
    initpos = position(e.io)
    !isempty(x.lane) && PB.encode(e, 1, x.lane)
    !isnothing(x.position) && PB.encode(e, 2, x.position)
    return position(e.io) - initpos
end
function PB._encoded_size(x::StopSign)
    encoded_size = 0
    !isempty(x.lane) && (encoded_size += PB._encoded_size(x.lane, 1))
    !isnothing(x.position) && (encoded_size += PB._encoded_size(x.position, 2))
    return encoded_size
end

struct SpeedBump
    polygon::Vector{MapPoint}
end
PB.default_values(::Type{SpeedBump}) = (;polygon = Vector{MapPoint}())
PB.field_numbers(::Type{SpeedBump}) = (;polygon = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SpeedBump})
    polygon = PB.BufferedVector{MapPoint}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, polygon)
        else
            PB.skip(d, wire_type)
        end
    end
    return SpeedBump(polygon[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SpeedBump)
    initpos = position(e.io)
    !isempty(x.polygon) && PB.encode(e, 1, x.polygon)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SpeedBump)
    encoded_size = 0
    !isempty(x.polygon) && (encoded_size += PB._encoded_size(x.polygon, 1))
    return encoded_size
end

struct RoadEdge
    var"#type"::var"RoadEdge.RoadEdgeType".T
    polyline::Vector{MapPoint}
end
PB.default_values(::Type{RoadEdge}) = (;var"#type" = var"RoadEdge.RoadEdgeType".TYPE_UNKNOWN, polyline = Vector{MapPoint}())
PB.field_numbers(::Type{RoadEdge}) = (;var"#type" = 1, polyline = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RoadEdge})
    var"#type" = var"RoadEdge.RoadEdgeType".TYPE_UNKNOWN
    polyline = PB.BufferedVector{MapPoint}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            var"#type" = PB.decode(d, var"RoadEdge.RoadEdgeType".T)
        elseif field_number == 2
            PB.decode!(d, polyline)
        else
            PB.skip(d, wire_type)
        end
    end
    return RoadEdge(var"#type", polyline[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RoadEdge)
    initpos = position(e.io)
    x.var"#type" != var"RoadEdge.RoadEdgeType".TYPE_UNKNOWN && PB.encode(e, 1, x.var"#type")
    !isempty(x.polyline) && PB.encode(e, 2, x.polyline)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RoadEdge)
    encoded_size = 0
    x.var"#type" != var"RoadEdge.RoadEdgeType".TYPE_UNKNOWN && (encoded_size += PB._encoded_size(x.var"#type", 1))
    !isempty(x.polyline) && (encoded_size += PB._encoded_size(x.polyline, 2))
    return encoded_size
end

struct RoadLine
    var"#type"::var"RoadLine.RoadLineType".T
    polyline::Vector{MapPoint}
end
PB.default_values(::Type{RoadLine}) = (;var"#type" = var"RoadLine.RoadLineType".TYPE_UNKNOWN, polyline = Vector{MapPoint}())
PB.field_numbers(::Type{RoadLine}) = (;var"#type" = 1, polyline = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RoadLine})
    var"#type" = var"RoadLine.RoadLineType".TYPE_UNKNOWN
    polyline = PB.BufferedVector{MapPoint}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            var"#type" = PB.decode(d, var"RoadLine.RoadLineType".T)
        elseif field_number == 2
            PB.decode!(d, polyline)
        else
            PB.skip(d, wire_type)
        end
    end
    return RoadLine(var"#type", polyline[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RoadLine)
    initpos = position(e.io)
    x.var"#type" != var"RoadLine.RoadLineType".TYPE_UNKNOWN && PB.encode(e, 1, x.var"#type")
    !isempty(x.polyline) && PB.encode(e, 2, x.polyline)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RoadLine)
    encoded_size = 0
    x.var"#type" != var"RoadLine.RoadLineType".TYPE_UNKNOWN && (encoded_size += PB._encoded_size(x.var"#type", 1))
    !isempty(x.polyline) && (encoded_size += PB._encoded_size(x.polyline, 2))
    return encoded_size
end

struct TrafficSignalLaneState
    lane::Int64
    state::var"TrafficSignalLaneState.State".T
    stop_point::Union{Nothing,MapPoint}
end
PB.default_values(::Type{TrafficSignalLaneState}) = (;lane = zero(Int64), state = var"TrafficSignalLaneState.State".LANE_STATE_UNKNOWN, stop_point = nothing)
PB.field_numbers(::Type{TrafficSignalLaneState}) = (;lane = 1, state = 2, stop_point = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TrafficSignalLaneState})
    lane = zero(Int64)
    state = var"TrafficSignalLaneState.State".LANE_STATE_UNKNOWN
    stop_point = Ref{Union{Nothing,MapPoint}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            lane = PB.decode(d, Int64)
        elseif field_number == 2
            state = PB.decode(d, var"TrafficSignalLaneState.State".T)
        elseif field_number == 3
            PB.decode!(d, stop_point)
        else
            PB.skip(d, wire_type)
        end
    end
    return TrafficSignalLaneState(lane, state, stop_point[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TrafficSignalLaneState)
    initpos = position(e.io)
    x.lane != zero(Int64) && PB.encode(e, 1, x.lane)
    x.state != var"TrafficSignalLaneState.State".LANE_STATE_UNKNOWN && PB.encode(e, 2, x.state)
    !isnothing(x.stop_point) && PB.encode(e, 3, x.stop_point)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TrafficSignalLaneState)
    encoded_size = 0
    x.lane != zero(Int64) && (encoded_size += PB._encoded_size(x.lane, 1))
    x.state != var"TrafficSignalLaneState.State".LANE_STATE_UNKNOWN && (encoded_size += PB._encoded_size(x.state, 2))
    !isnothing(x.stop_point) && (encoded_size += PB._encoded_size(x.stop_point, 3))
    return encoded_size
end

struct LaneCenter
    speed_limit_mph::Float64
    var"#type"::var"LaneCenter.LaneType".T
    interpolating::Bool
    polyline::Vector{MapPoint}
end
PB.default_values(::Type{LaneCenter}) = (;speed_limit_mph = zero(Float64), var"#type" = var"LaneCenter.LaneType".TYPE_UNDEFINED, interpolating = false, polyline = Vector{MapPoint}())
PB.field_numbers(::Type{LaneCenter}) = (;speed_limit_mph = 1, var"#type" = 2, interpolating = 3, polyline = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LaneCenter})
    speed_limit_mph = zero(Float64)
    var"#type" = var"LaneCenter.LaneType".TYPE_UNDEFINED
    interpolating = false
    polyline = PB.BufferedVector{MapPoint}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            speed_limit_mph = PB.decode(d, Float64)
        elseif field_number == 2
            var"#type" = PB.decode(d, var"LaneCenter.LaneType".T)
        elseif field_number == 3
            interpolating = PB.decode(d, Bool)
        elseif field_number == 8
            PB.decode!(d, polyline)
        else
            PB.skip(d, wire_type)
        end
    end
    return LaneCenter(speed_limit_mph, var"#type", interpolating, polyline[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LaneCenter)
    initpos = position(e.io)
    x.speed_limit_mph != zero(Float64) && PB.encode(e, 1, x.speed_limit_mph)
    x.var"#type" != var"LaneCenter.LaneType".TYPE_UNDEFINED && PB.encode(e, 2, x.var"#type")
    x.interpolating != false && PB.encode(e, 3, x.interpolating)
    !isempty(x.polyline) && PB.encode(e, 8, x.polyline)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LaneCenter)
    encoded_size = 0
    x.speed_limit_mph != zero(Float64) && (encoded_size += PB._encoded_size(x.speed_limit_mph, 1))
    x.var"#type" != var"LaneCenter.LaneType".TYPE_UNDEFINED && (encoded_size += PB._encoded_size(x.var"#type", 2))
    x.interpolating != false && (encoded_size += PB._encoded_size(x.interpolating, 3))
    !isempty(x.polyline) && (encoded_size += PB._encoded_size(x.polyline, 8))
    return encoded_size
end

struct DynamicState
    timestamp_seconds::Float64
    lane_states::Vector{TrafficSignalLaneState}
end
PB.default_values(::Type{DynamicState}) = (;timestamp_seconds = zero(Float64), lane_states = Vector{TrafficSignalLaneState}())
PB.field_numbers(::Type{DynamicState}) = (;timestamp_seconds = 1, lane_states = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DynamicState})
    timestamp_seconds = zero(Float64)
    lane_states = PB.BufferedVector{TrafficSignalLaneState}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            timestamp_seconds = PB.decode(d, Float64)
        elseif field_number == 2
            PB.decode!(d, lane_states)
        else
            PB.skip(d, wire_type)
        end
    end
    return DynamicState(timestamp_seconds, lane_states[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DynamicState)
    initpos = position(e.io)
    x.timestamp_seconds != zero(Float64) && PB.encode(e, 1, x.timestamp_seconds)
    !isempty(x.lane_states) && PB.encode(e, 2, x.lane_states)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DynamicState)
    encoded_size = 0
    x.timestamp_seconds != zero(Float64) && (encoded_size += PB._encoded_size(x.timestamp_seconds, 1))
    !isempty(x.lane_states) && (encoded_size += PB._encoded_size(x.lane_states, 2))
    return encoded_size
end

struct MapFeature
    id::Int64
    feature_data::Union{Nothing,OneOf{<:Union{LaneCenter,RoadLine,RoadEdge,StopSign,Crosswalk,SpeedBump}}}
end
PB.oneof_field_types(::Type{MapFeature}) = (;
    feature_data = (;lane=LaneCenter, road_line=RoadLine, road_edge=RoadEdge, stop_sign=StopSign, crosswalk=Crosswalk, speed_bump=SpeedBump),
)
PB.default_values(::Type{MapFeature}) = (;id = zero(Int64), lane = nothing, road_line = nothing, road_edge = nothing, stop_sign = nothing, crosswalk = nothing, speed_bump = nothing)
PB.field_numbers(::Type{MapFeature}) = (;id = 1, lane = 3, road_line = 4, road_edge = 5, stop_sign = 7, crosswalk = 8, speed_bump = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MapFeature})
    id = zero(Int64)
    feature_data = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            id = PB.decode(d, Int64)
        elseif field_number == 3
            feature_data = OneOf(:lane, PB.decode(d, Ref{LaneCenter}))
        elseif field_number == 4
            feature_data = OneOf(:road_line, PB.decode(d, Ref{RoadLine}))
        elseif field_number == 5
            feature_data = OneOf(:road_edge, PB.decode(d, Ref{RoadEdge}))
        elseif field_number == 7
            feature_data = OneOf(:stop_sign, PB.decode(d, Ref{StopSign}))
        elseif field_number == 8
            feature_data = OneOf(:crosswalk, PB.decode(d, Ref{Crosswalk}))
        elseif field_number == 9
            feature_data = OneOf(:speed_bump, PB.decode(d, Ref{SpeedBump}))
        else
            PB.skip(d, wire_type)
        end
    end
    return MapFeature(id, feature_data)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MapFeature)
    initpos = position(e.io)
    x.id != zero(Int64) && PB.encode(e, 1, x.id)
    if isnothing(x.feature_data);
    elseif x.feature_data.name === :lane
        PB.encode(e, 3, x.feature_data[]::LaneCenter)
    elseif x.feature_data.name === :road_line
        PB.encode(e, 4, x.feature_data[]::RoadLine)
    elseif x.feature_data.name === :road_edge
        PB.encode(e, 5, x.feature_data[]::RoadEdge)
    elseif x.feature_data.name === :stop_sign
        PB.encode(e, 7, x.feature_data[]::StopSign)
    elseif x.feature_data.name === :crosswalk
        PB.encode(e, 8, x.feature_data[]::Crosswalk)
    elseif x.feature_data.name === :speed_bump
        PB.encode(e, 9, x.feature_data[]::SpeedBump)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::MapFeature)
    encoded_size = 0
    x.id != zero(Int64) && (encoded_size += PB._encoded_size(x.id, 1))
    if isnothing(x.feature_data);
    elseif x.feature_data.name === :lane
        encoded_size += PB._encoded_size(x.feature_data[]::LaneCenter, 3)
    elseif x.feature_data.name === :road_line
        encoded_size += PB._encoded_size(x.feature_data[]::RoadLine, 4)
    elseif x.feature_data.name === :road_edge
        encoded_size += PB._encoded_size(x.feature_data[]::RoadEdge, 5)
    elseif x.feature_data.name === :stop_sign
        encoded_size += PB._encoded_size(x.feature_data[]::StopSign, 7)
    elseif x.feature_data.name === :crosswalk
        encoded_size += PB._encoded_size(x.feature_data[]::Crosswalk, 8)
    elseif x.feature_data.name === :speed_bump
        encoded_size += PB._encoded_size(x.feature_data[]::SpeedBump, 9)
    end
    return encoded_size
end

struct Map
    map_features::Vector{MapFeature}
    dynamic_states::Vector{DynamicState}
end
PB.default_values(::Type{Map}) = (;map_features = Vector{MapFeature}(), dynamic_states = Vector{DynamicState}())
PB.field_numbers(::Type{Map}) = (;map_features = 1, dynamic_states = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Map})
    map_features = PB.BufferedVector{MapFeature}()
    dynamic_states = PB.BufferedVector{DynamicState}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, map_features)
        elseif field_number == 2
            PB.decode!(d, dynamic_states)
        else
            PB.skip(d, wire_type)
        end
    end
    return Map(map_features[], dynamic_states[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Map)
    initpos = position(e.io)
    !isempty(x.map_features) && PB.encode(e, 1, x.map_features)
    !isempty(x.dynamic_states) && PB.encode(e, 2, x.dynamic_states)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Map)
    encoded_size = 0
    !isempty(x.map_features) && (encoded_size += PB._encoded_size(x.map_features, 1))
    !isempty(x.dynamic_states) && (encoded_size += PB._encoded_size(x.dynamic_states, 2))
    return encoded_size
end
