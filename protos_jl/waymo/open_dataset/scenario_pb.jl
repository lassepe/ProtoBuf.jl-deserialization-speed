# Autogenerated using ProtoBuf.jl v1.0.15 on 2024-01-22T14:43:16.837
# original file: /home/lassepe/worktree/BugReports/ProtoBuf.jl-deserialization-speed/protos/scenario.proto (proto2 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export ObjectState, var"RequiredPrediction.DifficultyLevel", DynamicMapState
export var"Track.ObjectType", RequiredPrediction, Track, Scenario

struct ObjectState
    center_x::Float64
    center_y::Float64
    center_z::Float64
    length::Float32
    width::Float32
    height::Float32
    heading::Float32
    velocity_x::Float32
    velocity_y::Float32
    valid::Bool
end
PB.default_values(::Type{ObjectState}) = (;center_x = zero(Float64), center_y = zero(Float64), center_z = zero(Float64), length = zero(Float32), width = zero(Float32), height = zero(Float32), heading = zero(Float32), velocity_x = zero(Float32), velocity_y = zero(Float32), valid = false)
PB.field_numbers(::Type{ObjectState}) = (;center_x = 2, center_y = 3, center_z = 4, length = 5, width = 6, height = 7, heading = 8, velocity_x = 9, velocity_y = 10, valid = 11)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ObjectState})
    center_x = zero(Float64)
    center_y = zero(Float64)
    center_z = zero(Float64)
    length = zero(Float32)
    width = zero(Float32)
    height = zero(Float32)
    heading = zero(Float32)
    velocity_x = zero(Float32)
    velocity_y = zero(Float32)
    valid = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 2
            center_x = PB.decode(d, Float64)
        elseif field_number == 3
            center_y = PB.decode(d, Float64)
        elseif field_number == 4
            center_z = PB.decode(d, Float64)
        elseif field_number == 5
            length = PB.decode(d, Float32)
        elseif field_number == 6
            width = PB.decode(d, Float32)
        elseif field_number == 7
            height = PB.decode(d, Float32)
        elseif field_number == 8
            heading = PB.decode(d, Float32)
        elseif field_number == 9
            velocity_x = PB.decode(d, Float32)
        elseif field_number == 10
            velocity_y = PB.decode(d, Float32)
        elseif field_number == 11
            valid = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return ObjectState(center_x, center_y, center_z, length, width, height, heading, velocity_x, velocity_y, valid)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ObjectState)
    initpos = position(e.io)
    x.center_x != zero(Float64) && PB.encode(e, 2, x.center_x)
    x.center_y != zero(Float64) && PB.encode(e, 3, x.center_y)
    x.center_z != zero(Float64) && PB.encode(e, 4, x.center_z)
    x.length != zero(Float32) && PB.encode(e, 5, x.length)
    x.width != zero(Float32) && PB.encode(e, 6, x.width)
    x.height != zero(Float32) && PB.encode(e, 7, x.height)
    x.heading != zero(Float32) && PB.encode(e, 8, x.heading)
    x.velocity_x != zero(Float32) && PB.encode(e, 9, x.velocity_x)
    x.velocity_y != zero(Float32) && PB.encode(e, 10, x.velocity_y)
    x.valid != false && PB.encode(e, 11, x.valid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ObjectState)
    encoded_size = 0
    x.center_x != zero(Float64) && (encoded_size += PB._encoded_size(x.center_x, 2))
    x.center_y != zero(Float64) && (encoded_size += PB._encoded_size(x.center_y, 3))
    x.center_z != zero(Float64) && (encoded_size += PB._encoded_size(x.center_z, 4))
    x.length != zero(Float32) && (encoded_size += PB._encoded_size(x.length, 5))
    x.width != zero(Float32) && (encoded_size += PB._encoded_size(x.width, 6))
    x.height != zero(Float32) && (encoded_size += PB._encoded_size(x.height, 7))
    x.heading != zero(Float32) && (encoded_size += PB._encoded_size(x.heading, 8))
    x.velocity_x != zero(Float32) && (encoded_size += PB._encoded_size(x.velocity_x, 9))
    x.velocity_y != zero(Float32) && (encoded_size += PB._encoded_size(x.velocity_y, 10))
    x.valid != false && (encoded_size += PB._encoded_size(x.valid, 11))
    return encoded_size
end

@enumx var"RequiredPrediction.DifficultyLevel" NONE=0 LEVEL_1=1 LEVEL_2=2

struct DynamicMapState
    lane_states::Vector{TrafficSignalLaneState}
end
PB.default_values(::Type{DynamicMapState}) = (;lane_states = Vector{TrafficSignalLaneState}())
PB.field_numbers(::Type{DynamicMapState}) = (;lane_states = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DynamicMapState})
    lane_states = PB.BufferedVector{TrafficSignalLaneState}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, lane_states)
        else
            PB.skip(d, wire_type)
        end
    end
    return DynamicMapState(lane_states[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DynamicMapState)
    initpos = position(e.io)
    !isempty(x.lane_states) && PB.encode(e, 1, x.lane_states)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DynamicMapState)
    encoded_size = 0
    !isempty(x.lane_states) && (encoded_size += PB._encoded_size(x.lane_states, 1))
    return encoded_size
end

@enumx var"Track.ObjectType" TYPE_UNSET=0 TYPE_VEHICLE=1 TYPE_PEDESTRIAN=2 TYPE_CYCLIST=3 TYPE_OTHER=4

struct RequiredPrediction
    track_index::Int32
    difficulty::var"RequiredPrediction.DifficultyLevel".T
end
PB.default_values(::Type{RequiredPrediction}) = (;track_index = zero(Int32), difficulty = var"RequiredPrediction.DifficultyLevel".NONE)
PB.field_numbers(::Type{RequiredPrediction}) = (;track_index = 1, difficulty = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RequiredPrediction})
    track_index = zero(Int32)
    difficulty = var"RequiredPrediction.DifficultyLevel".NONE
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            track_index = PB.decode(d, Int32)
        elseif field_number == 2
            difficulty = PB.decode(d, var"RequiredPrediction.DifficultyLevel".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return RequiredPrediction(track_index, difficulty)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RequiredPrediction)
    initpos = position(e.io)
    x.track_index != zero(Int32) && PB.encode(e, 1, x.track_index)
    x.difficulty != var"RequiredPrediction.DifficultyLevel".NONE && PB.encode(e, 2, x.difficulty)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RequiredPrediction)
    encoded_size = 0
    x.track_index != zero(Int32) && (encoded_size += PB._encoded_size(x.track_index, 1))
    x.difficulty != var"RequiredPrediction.DifficultyLevel".NONE && (encoded_size += PB._encoded_size(x.difficulty, 2))
    return encoded_size
end

struct Track
    id::Int32
    object_type::var"Track.ObjectType".T
    states::Vector{ObjectState}
end
PB.default_values(::Type{Track}) = (;id = zero(Int32), object_type = var"Track.ObjectType".TYPE_UNSET, states = Vector{ObjectState}())
PB.field_numbers(::Type{Track}) = (;id = 1, object_type = 2, states = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Track})
    id = zero(Int32)
    object_type = var"Track.ObjectType".TYPE_UNSET
    states = PB.BufferedVector{ObjectState}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            id = PB.decode(d, Int32)
        elseif field_number == 2
            object_type = PB.decode(d, var"Track.ObjectType".T)
        elseif field_number == 3
            PB.decode!(d, states)
        else
            PB.skip(d, wire_type)
        end
    end
    return Track(id, object_type, states[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Track)
    initpos = position(e.io)
    x.id != zero(Int32) && PB.encode(e, 1, x.id)
    x.object_type != var"Track.ObjectType".TYPE_UNSET && PB.encode(e, 2, x.object_type)
    !isempty(x.states) && PB.encode(e, 3, x.states)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Track)
    encoded_size = 0
    x.id != zero(Int32) && (encoded_size += PB._encoded_size(x.id, 1))
    x.object_type != var"Track.ObjectType".TYPE_UNSET && (encoded_size += PB._encoded_size(x.object_type, 2))
    !isempty(x.states) && (encoded_size += PB._encoded_size(x.states, 3))
    return encoded_size
end

struct Scenario
    scenario_id::String
    timestamps_seconds::Vector{Float64}
    current_time_index::Int32
    tracks::Vector{Track}
    dynamic_map_states::Vector{DynamicMapState}
    map_features::Vector{MapFeature}
    sdc_track_index::Int32
    objects_of_interest::Vector{Int32}
    tracks_to_predict::Vector{RequiredPrediction}
end
PB.reserved_fields(::Type{Scenario}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[9])
PB.default_values(::Type{Scenario}) = (;scenario_id = "", timestamps_seconds = Vector{Float64}(), current_time_index = zero(Int32), tracks = Vector{Track}(), dynamic_map_states = Vector{DynamicMapState}(), map_features = Vector{MapFeature}(), sdc_track_index = zero(Int32), objects_of_interest = Vector{Int32}(), tracks_to_predict = Vector{RequiredPrediction}())
PB.field_numbers(::Type{Scenario}) = (;scenario_id = 5, timestamps_seconds = 1, current_time_index = 10, tracks = 2, dynamic_map_states = 7, map_features = 8, sdc_track_index = 6, objects_of_interest = 4, tracks_to_predict = 11)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Scenario})
    scenario_id = ""
    timestamps_seconds = PB.BufferedVector{Float64}()
    current_time_index = zero(Int32)
    tracks = PB.BufferedVector{Track}()
    dynamic_map_states = PB.BufferedVector{DynamicMapState}()
    map_features = PB.BufferedVector{MapFeature}()
    sdc_track_index = zero(Int32)
    objects_of_interest = PB.BufferedVector{Int32}()
    tracks_to_predict = PB.BufferedVector{RequiredPrediction}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 5
            scenario_id = PB.decode(d, String)
        elseif field_number == 1
            PB.decode!(d, wire_type, timestamps_seconds)
        elseif field_number == 10
            current_time_index = PB.decode(d, Int32)
        elseif field_number == 2
            PB.decode!(d, tracks)
        elseif field_number == 7
            PB.decode!(d, dynamic_map_states)
        elseif field_number == 8
            PB.decode!(d, map_features)
        elseif field_number == 6
            sdc_track_index = PB.decode(d, Int32)
        elseif field_number == 4
            PB.decode!(d, wire_type, objects_of_interest)
        elseif field_number == 11
            PB.decode!(d, tracks_to_predict)
        else
            PB.skip(d, wire_type)
        end
    end
    return Scenario(scenario_id, timestamps_seconds[], current_time_index, tracks[], dynamic_map_states[], map_features[], sdc_track_index, objects_of_interest[], tracks_to_predict[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Scenario)
    initpos = position(e.io)
    !isempty(x.scenario_id) && PB.encode(e, 5, x.scenario_id)
    !isempty(x.timestamps_seconds) && PB.encode(e, 1, x.timestamps_seconds)
    x.current_time_index != zero(Int32) && PB.encode(e, 10, x.current_time_index)
    !isempty(x.tracks) && PB.encode(e, 2, x.tracks)
    !isempty(x.dynamic_map_states) && PB.encode(e, 7, x.dynamic_map_states)
    !isempty(x.map_features) && PB.encode(e, 8, x.map_features)
    x.sdc_track_index != zero(Int32) && PB.encode(e, 6, x.sdc_track_index)
    !isempty(x.objects_of_interest) && PB.encode(e, 4, x.objects_of_interest)
    !isempty(x.tracks_to_predict) && PB.encode(e, 11, x.tracks_to_predict)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Scenario)
    encoded_size = 0
    !isempty(x.scenario_id) && (encoded_size += PB._encoded_size(x.scenario_id, 5))
    !isempty(x.timestamps_seconds) && (encoded_size += PB._encoded_size(x.timestamps_seconds, 1))
    x.current_time_index != zero(Int32) && (encoded_size += PB._encoded_size(x.current_time_index, 10))
    !isempty(x.tracks) && (encoded_size += PB._encoded_size(x.tracks, 2))
    !isempty(x.dynamic_map_states) && (encoded_size += PB._encoded_size(x.dynamic_map_states, 7))
    !isempty(x.map_features) && (encoded_size += PB._encoded_size(x.map_features, 8))
    x.sdc_track_index != zero(Int32) && (encoded_size += PB._encoded_size(x.sdc_track_index, 6))
    !isempty(x.objects_of_interest) && (encoded_size += PB._encoded_size(x.objects_of_interest, 4))
    !isempty(x.tracks_to_predict) && (encoded_size += PB._encoded_size(x.tracks_to_predict, 11))
    return encoded_size
end
